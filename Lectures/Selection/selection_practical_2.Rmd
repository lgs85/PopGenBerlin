---
title: 'Selection: practical 2'
author: "Lewis Spurgin"
output:
  html_document:
    css: js/styles.css
---

<script src="js/hide.js"></script>

## Introduction
In this practical we will look at two approaches for detecting *recent* selection among populations - one that requires discrete, predefined populations, and one that does not

## The data
We will be using the great tit data set from the population structure practical. You do not need to copy the file across.

In this session we are looking for loci under selection, so we do not want to filter based on Hardy-Weinberg, or to prune based on LD, as this would remove loads of interesting information. However, we still want to exclude unrelated individuals. You can create such a file using the information you generated in the population structure practical folder using a single line of plink code. Write a new plink file to the selection folder. The file should contain only unrelated individuals, but all markers

<div class="fold s">
```{R, eval = F}
plink --bfile ../population_structure/GreatTits --keep ../population_structure/GreatTitsFilteredPruned.rel.id --make-bed --out GreatTitsUnrel
```
</div>


## Locus $F_{ST}$
We can calculate $F_{ST}$ very easily within plink - in fact we have already done this in the population structure practical, using a python script. But in that instance we were only interested in average $F_{ST}$ across pairs of populations. We are now interested in the $F_{ST}$ for each marker across all of our populations. Can you figure out how to calculate this?

<div class="fold s">
```{R, eval = F}
plink --bfile GreatTitsUnrel --family --fst --out GreatTitsUnrel
```
</div>

Check the plink help and make sure you are happy with what the "family" tag is doing. Regardless, is this the best way to define our populations? What did our Admixture results show? We will now try to use our Admixture results from the $K$ = 4 analysis to assign each individual to an "Admixture population", then run a locus-based $F_{ST}$ analysis across the Admixture populations. If you think you can do this, go for it! Otherwise, step-by-step instructions below.

Remember that your ".Q" file from the Admixture analysis has one line per individual, with individuals in the same order as in your plink file. It then has the proportion of each cluster assigned to each individual as a separate column (so 4 columns for the $K$ - 4 analysis). What we need to do is determine, for each individual, which is the 'largest' of the four clusters. We can do this in R. Start up R in your server console, then load your admixture into a data frame.

<div class="fold s">
```{R, eval = F}
R

dd <- read.table("../population_structure/admixture/GreatTitsThinned.4.Q",header = F)
```
</div>

Change the column names to "K1" to "K4".

<div class="fold s">
```{R, eval = F}
colnames(dd) <- paste0("K",c(1:4))
```
</div>

We now wish to generate a vector that tells us, for each individual, which of K1 to K4 is largest. Can you figure out how to do this, either using a `for()` loop, or using `apply()`?

<div class="fold s">
```{R, eval = F}
#Using a for loop
output <- rep(NA,nrow(dd))
for(i in 1:nrow(dd))
{
  output[i] <- names(which.max(dd[i,]))
}

#Using apply - faster and neater
output <- apply(dd,1,function(x) names(which.max(x)))

```
</div>

Make sure that you fully understand how the above code has worked. Look up the help files for each function in the code, and discuss with your colleagues. 

To define populations in plink, we are going to need to give it a file with our original population IDs in the first column, individual IDs in the second, and new population IDs in the third. We can create this using our output, and our.fam file. Load the .fam file into R

<div class="fold s">
```{r, eval = F}
pops <- read.table("GreatTitsUnrel.fam")
```
</div>

Now write an output file.

<div class="fold s">
```{r, eval = F}
towrite <- data.frame(oldpop = pops$V1,ind = pops$V2,newpop = output)
write.table(towrite,"K4pops.txt",quote = F,col.names = F, row.names = F)
```
</div>

Now we can quit R, and use plink to calculate FST based on our admixture proportions.

<div class="fold s">
```{r, eval = F}
plink --bfile GreatTitsUnrel --within K4pops.txt --fst --out GreatTitsK4
```
</div>

##EigenGWAS

Have a read of the EigenGWAS documentation here. This approach, along with a few other closely related approaches uses a GWAS on eigenvectors from a PCA to detect loci under divergent selection.

Navigate into the EigenGWAS folder. Now try to figure out how to run EigenGWAS on the first four eigenvectors from a PCA.

<div class="fold s">
```{r eval = F}
java -jar gear.jar eigengwas --bfile ../GreatTitsUnrel --ev 4 --out GreatTitsUnrel #Doesn't work - seems to want the output to be called "null"!

java -jar gear.jar eigengwas --bfile ../GreatTitsUnrel --ev 4 --out null #works
```
</div>

This is a new piece of software. As far as I am able to see there is a bug in the command meaning that it doesn't run unless you specify the output name like this. You can always change the names of these output files using $\mv$.

This analysis will take a little while to run - while it's running, you can start downloading your other files - a list of what you need to download is below.

Given the bug we found, it would be sensible to check the output files from the EigenGWAS *very carefully*. Indeed, there are problems with some of the output files, which we will come to later. But see if you can spot and correct these problems now!

##Making plots
Copy the following files to a folder called session8_output:

- FST between your geographic populations (first plink analysis, ending in .fst)
- FST between your admixture populations (second plink analysis, ending in .fst)
- Your Eigenvectors from the EigenGWAS analysis (ending in .eigenvec)
- Your EigenGWAS results (four files, all ending in .egwas)
- The R script sliding_window.r

Now download this file to your laptop using scp or pscp.

We are going to do the plotting slightly differently this time. I will introduce you to some of the plots and functions you can run, then it is up to you to make a publication quality figure from our selection analyses.

Let's first explore our FST analyses. These are large files, with FST values calculated for all 250,000 or so markers. So rather than using `read.table()` we will use `fread()` from the `data.table` library.

<div class="fold s">
```{r}
library(data.table)
pop_fst <- fread("~/Documents/Teaching/PopGenBerlinLGS/session8_output/GreatTitsUnrel.fst")

head(pop_fst)
```
</div>

We can explore the distribution of FST values using `geom_histogram()` or `geom_density()`.
<div class="fold s">
```{r,fig.width=7,fig.height=3,warning = F,message = F}
library(ggplot2)
library(Rmisc)

h1 <- ggplot(pop_fst,aes(x = FST))+
  geom_histogram()
d1 <- ggplot(pop_fst,aes(x = FST))+
  geom_density()

multiplot(h1,d1,cols = 2)
```
</div>

What do these distributions tell you about drift and selection in this system?

We can also read in our FST values from our admixture populations, and compare marker-based FST values. Rather than plot all 250,0000 points. Think of a good way of plotting the two sets of FST values against one another in a way that summarises the data.


<div class="fold s">
```{r,fig.width=6,fig.height=5,warning = F,message = F,cache = T}
ad_fst <- fread("~/Documents/Teaching/PopGenBerlinLGS/session8_output/GreatTitsK4.fst")

pop_fst$ADFST <- ad_fst$FST

ggplot(pop_fst,aes(x = FST,y = ADFST))+
  stat_density2d(aes(alpha=..level..), geom="polygon") +
  theme_bw()

```
</div>


Check the correlation coefficient between the two measures...
<div class="fold s">
```{r}
cor(pop_fst$FST,pop_fst$ADFST)

#Need to remove NAs and try again
pop_fst <- subset(subset(pop_fst,!is.na(FST)),!(is.na(ADFST)))
cor(pop_fst$FST,pop_fst$ADFST)
```
</div>

Let's now take a look at the EigenGWAS data. First at the eigenvector file.
<div class="fold s">
```{r}
ev <- read.table("~/Documents/Teaching/PopGenBerlinLGS/session8_output/null.eigenvec")
head(ev)
```
</div>

This conveniently has the population and individual IDs as the first two columns. Define come column names.

<div class="fold s">
```{r}
colnames(ev) <- c("Population","Individual",paste0("PC",c(1:4)))
```
</div>

Now make some PCA plots

<div class="fold s">
```{r,fig.width=10,fig.height=3,warning = F,message = F,cache = T}
F1 <- ggplot(ev,aes(x = PC1,y = PC2,col = Population))+
  geom_point()

F2 <- ggplot(ev,aes(x = PC3,y = PC4,col = Population))+
  geom_point()

multiplot(F1,F2,cols = 2)
```
</div>

EigenGWAS runs a GWAS on each of these four Eigenvectors. What do these four analyses tell us about selection?

Let's load in the analysis from the first Eigenvector and take a look at the results. As you will see there are some issues with the results files EigenGWAS has given us.

```{r, message = F, warning = F,cache = T}
eg1 <- fread("~/Documents/Teaching/PopGenBerlinLGS/session8_output/null.1.egwas",data.table = F) #some issues with this text file - use read.table as it's simpler

eg1 <- read.table("~/Documents/Teaching/PopGenBerlinLGS/session8_output/null.1.egwas", header = T,stringsAsFactors = F) #Slower but works
str(eg1)

#Some variables read in as character - read as numeric
eg1[,c("Beta","SE","Chi","P","PGC","Fst")] <- apply(eg1[,c("Beta","SE","Chi","P","PGC","Fst")],2,as.numeric)

#Some check which rows have been converted to NAs 
head(eg1[is.na(eg1$Beta),])

#these are loci in which there is no variation in these populations. Fine to exclude them

eg1 <- eg1[complete.cases(eg1),]

head(eg1)
```

Can you figure out from the above, and from using the command line, what was wrong with the output from EigenGWAS? Is it ok now? We have to bear in mind that most pieces of pop gen software are made by scientists like us, so are not perfectly coded!

Let's see how well out EigenGWAS p value and FST are correlated
```{r}
cor(eg1$PGC,eg1$Fst)
```

They are strongly negatively correlated. Is that what we expect?

Finally, we will use the `manhattan()` function in the `qqman` library to produce a Manhattan plot of the corrected EigenGWAS p-values. Try to reproduce the plot below, using help that you can find online. Then see if your code matches mine.

<div class="fold s">
```{r,warning = F, message = F, fig.width=10,fig.height = 4,cache = T}

library(qqman)
manhattan(eg1,chr = "CHR",p = "PGC",bp = "BP")
```
</div>

Now use the `qq()` function to produce a qq plot of the corrected and uncorrected p values.

<div class="fold s">
```{r,warning = F, message = F, cache = T}
#Uncorrected
qq(eg1$P)

#Corrected
qq(eg1$PGC)
```
</div>

How do you interpret these plots? Do we have to worry about false positives in our data? Which points are "significant"? Is the correction working?


##Over to you
Make a publication-quality figure summarising the selection analyses you have done. You can adapt figures we have already made or (better still) make completely new ones. For example, you may want to consider:

- Manhattan plots for the other eigenvectors
- Manhattan plots of sliding window $F_{ST}$ (see the "sliding_window.r" script - can you get this working?)
- Going to the great tit reference genome (link below) and finding whether SNPs under divergent selection are in genes
  https://www.ncbi.nlm.nih.gov/genome/gdv/browser/?context=genome&acc=GCF_001522545.2
- Combining your selection and population structure plots into a single figure.

Be creative!

